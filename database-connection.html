<!DOCTYPE html>
<html>
<head>

    <!-- Document Settings -->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Base Meta -->
    <!-- dynamically fixing the title for tag/author pages -->



    <title>Database Connection Pool and Persistent Connection</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <!-- Styles'n'Scripts -->
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/screen.edited.css" />
    <link rel="stylesheet" type="text/css" href="/assets/built/syntax.css" />
    <!-- highlight.js -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <style>.hljs { background: none; }</style>

    <!-- This tag outputs SEO meta+structured data and other important settings -->
    <meta name="description" content="I'll post anything I interest in." />
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({
            google_ad_client: "ca-pub-7151427137680177",
            enable_page_level_ads: true
        });
    </script>
    <link rel="shortcut icon" href="https://ohing504.github.io/assets/images/favicon.png" type="image/png" />
    <link rel="canonical" href="https://ohing504.github.io/database-connection" />
    <meta name="referrer" content="no-referrer-when-downgrade" />

     <!--title below is coming from _includes/dynamic_title-->
    <meta property="og:site_name" content="502 Blog" />
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Database Connection Pool and Persistent Connection" />
    <meta property="og:description" content="Database Connection Pool and Persistent Connection 지속적인 연결(Persistent Connection) 이란? 영속적인 커넥션은 얼마간 연결을 열어놓고 여러 요청에 재사용함으로써, 새로운 TCP 핸드셰이크를 하는 비용을 아끼고, TCP의 성능 향상 기능을 활용할 수 있습니다. 커넥션은 영원히 열려있는지 않으며, 유휴 커넥션들은 얼마 후에 닫힙니다(서버는 Keep-Alive 헤더를 사용해서 연결이 최소한 얼마나 열려있어야 할지를 설정할 수" />
    <meta property="og:url" content="https://ohing504.github.io/database-connection" />
    <meta property="og:image" content="https://ohing504.github.io/assets/images/covers/book-1659717_1280.jpg" />
    <meta property="article:publisher" content="https://www.facebook.com/false" />
    <meta property="article:author" content="https://www.facebook.com/false" />
    <meta property="article:published_time" content="2018-10-08T01:24:00+00:00" />
    <meta property="article:modified_time" content="2018-10-08T01:24:00+00:00" />
    <meta property="article:tag" content="Database" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Database Connection Pool and Persistent Connection" />
    <meta name="twitter:description" content="Database Connection Pool and Persistent Connection 지속적인 연결(Persistent Connection) 이란? 영속적인 커넥션은 얼마간 연결을 열어놓고 여러 요청에 재사용함으로써, 새로운 TCP 핸드셰이크를 하는 비용을 아끼고, TCP의 성능 향상 기능을 활용할 수 있습니다. 커넥션은 영원히 열려있는지 않으며, 유휴 커넥션들은 얼마 후에 닫힙니다(서버는 Keep-Alive 헤더를 사용해서 연결이 최소한 얼마나 열려있어야 할지를 설정할 수" />
    <meta name="twitter:url" content="https://ohing504.github.io/" />
    <meta name="twitter:image" content="https://ohing504.github.io/assets/images/covers/book-1659717_1280.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="502 Blog" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="Database" />
    <meta name="twitter:site" content="@false" />
    <meta name="twitter:creator" content="@false" />
    <meta property="og:image:width" content="1400" />
    <meta property="og:image:height" content="933" />

    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Website",
    "publisher": {
        "@type": "Organization",
        "name": "502 Blog",
        "logo": "https://ohing504.github.io/assets/images/blog-icon.png"
    },
    "url": "https://ohing504.github.io/database-connection",
    "image": {
        "@type": "ImageObject",
        "url": "https://ohing504.github.io/assets/images/covers/book-1659717_1280.jpg",
        "width": 2000,
        "height": 666
    },
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://ohing504.github.io/database-connection"
    },
    "description": "Database Connection Pool and Persistent Connection 지속적인 연결(Persistent Connection) 이란? 영속적인 커넥션은 얼마간 연결을 열어놓고 여러 요청에 재사용함으로써, 새로운 TCP 핸드셰이크를 하는 비용을 아끼고, TCP의 성능 향상 기능을 활용할 수 있습니다. 커넥션은 영원히 열려있는지 않으며, 유휴 커넥션들은 얼마 후에 닫힙니다(서버는 Keep-Alive 헤더를 사용해서 연결이 최소한 얼마나 열려있어야 할지를 설정할 수"
}
    </script>

    <!-- <script type="text/javascript" src="https://demo.ghost.io/public/ghost-sdk.min.js?v=724281a32e"></script>
    <script type="text/javascript">
    ghost.init({
    	clientId: "ghost-frontend",
    	clientSecret: "f84a07a72b17"
    });
    </script> -->

    <meta name="generator" content="Jekyll 3.6.2" />
    <link rel="alternate" type="application/rss+xml" title="Database Connection Pool and Persistent Connection" href="/feed.xml" />


</head>
<body class="post-template">

    <div class="site-wrapper">
        <!-- All the main content gets inserted here, index.hbs, post.hbs, etc -->
        <!-- default -->

<!-- The tag above means: insert everything in this file
into the {body} of the default.hbs template -->

<header class="site-header outer">
    <div class="inner">
        <nav class="site-nav">
    <div class="site-nav-left">
        
            
                <a class="site-nav-logo" href="https://ohing504.github.io/"><img src="/assets/images/blog-icon.png" alt="502 Blog" /></a>
            
        
        
            <ul class="nav" role="menu">
    <li class="nav-home" role="menuitem"><a href="/">Home</a></li>
    <li class="nav-getting-started" role="menuitem"><a href="/tag/getting-started/">Getting Started</a></li>
</ul>

        
    </div>
    <div class="site-nav-right">
        <div class="social-links">
            
            
        </div>
        
    </div>
</nav>

    </div>
</header>

<!-- Everything inside the #post tags pulls data from the post -->
<!-- #post -->

<main id="site-main" class="site-main outer" role="main">
    <div class="inner">

        <article class="post-full post ">

            <header class="post-full-header">
                <section class="post-full-meta">
                    <time class="post-full-meta-date" datetime=" 8 October 2018"> 8 October 2018</time>
                    
                        <span class="date-divider">/</span>
                        
                            
                               <a href='/tag/database/'>DATABASE</a>,
                            
                        
                            
                               <a href='/tag/connection/'>CONNECTION</a>,
                            
                        
                            
                               <a href='/tag/connection-pool/'>CONNECTION POOL</a>,
                            
                        
                            
                               <a href='/tag/persistent-connection/'>PERSISTENT CONNECTION</a>
                            
                        
                    
                </section>
                <h1 class="post-full-title">Database Connection Pool and Persistent Connection</h1>
            </header>

            
            <figure class="post-full-image" style="background-image: url(/assets/images/covers/book-1659717_1280.jpg)">
            </figure>
            

            <section class="post-full-content">
                <div class="kg-card-markdown">
                    <h1 id="database-connection-pool-and-persistent-connection">Database Connection Pool and Persistent Connection</h1>

<h2 id="지속적인-연결persistent-connection-이란">지속적인 연결(Persistent Connection) 이란?</h2>

<blockquote>
  <p><strong>영속적인 커넥션</strong>은 얼마간 연결을 열어놓고 여러 요청에 <strong>재사용</strong>함으로써, 새로운 TCP 핸드셰이크를 하는 비용을 아끼고, TCP의 성능 향상 기능을 활용할 수 있습니다. 커넥션은 영원히 열려있는지 않으며, 유휴 커넥션들은 얼마 후에 닫힙니다(서버는 Keep-Alive 헤더를 사용해서 연결이 최소한 얼마나 열려있어야 할지를 설정할 수 있습니다). from <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x">MDN web docs</a></p>
</blockquote>

<p><img src="https://mdn.mozillademos.org/files/13727/HTTP1_x_Connections.png" alt="" /></p>

<p>출처: <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x">https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x</a></p>

<p>위 그림을 보면 Multiple connections 또는 Short-lived connections (좌측)의 경우 3개의 요청을 처리하기 위해 커넥션을 매번 열었다 닫고있는 반면, Persistent connection (중앙)의 경우 하나의 커넥션으로 3개의 요청을 처리하는 것을 볼 수 있습니다.</p>

<h3 id="advantages-from-wiki">Advantages (from <a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection#Advantages">wiki</a>)</h3>

<ul>
  <li>후속 요청에서 대기 시간 감소 (핸드 쉐이크 없음).</li>
  <li>새로운 연결 및 TLS 핸드 셰이크가 적기 때문에 CPU 사용량 및 round-trips 시간이 줄어 듭니다.</li>
  <li>요청 및 응답의 HTTP 파이프 라이닝을 활성화합니다 (위 그림 중 우측).</li>
  <li>네트워크 혼잡 감소 (TCP 연결 감소).</li>
  <li>TCP 연결을 닫지 않아도 페널티없이 오류를보고 할 수 있습니다 (?).</li>
</ul>

<h3 id="disadvantages-from-wiki">Disadvantages (from <a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection#Disadvantages">wiki</a>)</h3>

<p>필요한 모든 데이터를 수신 한 후 클라이언트가 연결을 닫지 않으면 서버에서 연결을 유지하는 데 필요한 자원을 다른 클라이언트가 사용할 수 없게됩니다. 이것이 서버의 가용성에 영향을 미치는 정도와 리소스를 사용할 수없는 기간은 서버의 아키텍처 및 구성(max age, max connection 등)에 따라 다릅니다.</p>

<p>즉, <a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Connection_management_in_HTTP_1.x#%EC%98%81%EC%86%8D%EC%A0%81%EC%9D%B8_%EC%BB%A4%EB%84%A5%EC%85%98">유휴 상태일때에도 서버 리소스를 소비하며, 과부하 상태에서는 DoS attacks을 당할 수 있습니다.</a></p>

<h2 id="커넥션-풀conneciton-pool-이란">커넥션 풀(conneciton pool) 이란?</h2>

<blockquote>
  <p><strong>연결 풀</strong> 또는 <strong>커넥션 풀</strong>(connection pool)은 소프트웨어 공학에서 데이터베이스로의 추가 요청이 필요할 때 연결을 <strong>재사용</strong>할 수 있도록 관리되는 데이터베이스 연결의 <strong>캐시</strong>이다. 연결 풀을 사용하면 데이터베이스의 명령 실행의 성능을 강화할 수 있다. 각 사용자마다 데이터베이스 <em>연결을 열고 유지보수하는 것은 비용이 많이 들고 자원을 낭비</em>한다. 연결 풀의 경우 연결이 수립된 이후에 풀에 위치해 있으므로 다시 사용하면 새로운 연결을 수립할 필요가 없어진다. 모든 연결이 사용 중이면 새로운 연결을 만들고 풀에 추가된다. 연결 풀은 사용자가 데이터베이스에 연결을 수립하는데까지 대기해야하는 시간을 줄이기도 한다. from <a href="https://ko.wikipedia.org/wiki/연결_풀">wikipedia</a></p>
</blockquote>

<p>즉, DB 연결(connection)을 매번 여는 비용을 줄이기 위해 <strong>미리</strong> 만들어 놓고 <strong>재사용</strong>하는 것입니다.</p>

<p><img src="https://ejbvn.files.wordpress.com/2008/11/95.jpg" alt="" /></p>

<p>출처: <a href="https://ejbvn.wordpress.com/category/week-2-entity-beans-and-message-driven-beans/day-09-using-jdbc-to-connect-to-a-database/">https://ejbvn.wordpress.com/category/week-2-entity-beans-and-message-driven-beans/day-09-using-jdbc-to-connect-to-a-database/</a></p>

<p>위 그림을 보면, 커넥션 풀에 4개의 커넥션을 미리 만들어 두고, 클라이언트의 요청이 들어올 경우 새로 생성하는 것이 아니라 미리 생성된 커넥션으로 처리하는 것을 볼 수 있습니다. 만약 커넥션 풀 내의 모든 커넥션이 사용중이라면 클라이언트는 <strong>대기 상태</strong>로 전환되고, 커넥션이 반환되면 대기하고 있는 순서대로 커넥션이 제공됩니다. 만약 커넥션 풀을 사용하지 않는 경우 최대 커넥션 개수를 초과하면 에러로 인해 서버가 다운될 수 있습니다.</p>

<h2 id="connection-pooling-vs-persistent-connections">Connection Pooling vs. Persistent Connections</h2>

<p>위 설명만 봐서는 두 가지가 유사해 보입니다. 지속적 연결의 경우 생명이 정해져 있지만 커넥션 풀링에서는 정해져 있지 않다? 지속적 연결은 최대 개수를 설정하지 않지만 커넥션 풀링에서는 정해져 있다? 여러 서비스들을 살펴보면 지속적 연결과 커넥션 풀링이 비슷한 설정들을 사용하고 있습니다. 지속적 연결에서도 최대 개수를 지정해서 시스템에서 지원하는 최대 개수를 넘지 않도록 할 수 있고, 커넥션 풀링에서도 지속 시간을 두어 일정 시간마다 다시 열도록 설정할 수도 있습니다. 그렇다면 가장 큰 차이점은 무엇일까요?</p>

<blockquote>
  <p><strong>지속적인 연결</strong>(Persistent Connections)은 psycopg2, PDO, Hibernate 및 SQLObject와 같은 드라이버, 드라이버 프레임워크 및 ORM 도구의 기능입니다. 드라이버는 커넥션 핸들을 열어두어 <strong>동일한 프로세스</strong> <strong>또는 쓰레드</strong>에서 데이터베이스 엑세스가 다시 발생하는 경우 그것을 재사용합니다. 이를 통해 데이터베이스 인증 및 연결 시작 시간으로 인한 대기 시간을 줄일 수 있습니다.
<strong>연결 풀링</strong>(Connection Pooling)은 <a href="https://pgbouncer.github.io/">pgBouncer</a> 및 다양한 J2EE 서버와 같은 네트워크 프록시 및 응용 프로그램 서버의 기능입니다. 데이터베이스에 대한 지속적인 연결 풀이 유지되고 <strong>여러 응용 프로그램 서버간에 공유</strong>되어 하나 이상의 응용 프로그램 프로세스가 동일한 데이터베이스 커넥션을 공유 할 수 있는 경우가 많습니다. 이렇게하면 연결 시작 시간이 줄어들뿐만 아니라 적은 수의 데이터베이스 서버 커넥션을 보다 잘 관리할 수 있으므로 데이터베이스 서버의 로드가 줄어듭니다.
사용중인 툴에 최대 데이터베이스 연결 수 및 데이터베이스 연결 수명에 대한 구성 매개 변수가 없거나 별도의 서비스가 실행되지 않는 경우 연결 풀이 아닐 수 있습니다.
출처: <a href="http://www.databasesoup.com/2013/07/connection-pooling-vs-persistent.html">http://www.databasesoup.com/2013/07/connection-pooling-vs-persistent.html</a></p>
</blockquote>

<p>위 내용에서 보면, 지속적 연결은 <strong>단일 프로세스</strong> 내에서 동일한 프로세스 또는 쓰레드가 데이터베이스에 연결하는 것에 대한 기능입니다. 반면, 연결 풀링의 경우 <strong>다중 프로세스</strong>에서 데이터베이스에 연결하는 것데 대한 기능입니다. 연결 풀링 구현 중 하나인 pgBouncer는 연결 풀을 관리하는 프로세스가 독립적으로 동작하며, 응용 프로그램에서는 데이터베이스 대신 pgBouncer 프로세스에 접속하여 디비를 사용하게 됩니다.</p>

<h2 id="database-connection-in-django">Database Connection in Django</h2>

<p>Django 1.5 버전까지는 모든 HTTP 리퀘스트에 대해 새로운 커넥션을 생성하여 처리하였으며, 1.6 버전부터 Persistent Connection을 적용하였습니다 (<a href="https://docs.djangoproject.com/en/2.1/releases/1.6/#persistent-database-connections">Django 1.6 release notes</a>).</p>

<p>관련 설정으로 <strong><a href="https://docs.djangoproject.com/ko/2.1/ref/settings/#std:setting-CONN_MAX_AGE">CONN_MAX_AGE</a></strong> 값을 통해 커넥션의 유지 시간을 조절할 수 있습니다:</p>

<ul>
  <li>0: 리퀘스트가 완료되면 연결을 닫음 (Default)</li>
  <li>Positive: 해당 시간동안 커넥션을 유지 (in seconds)</li>
  <li>None: 커넥션을 계속 열어둠</li>
</ul>

<p>현재 Django는 커넥션 풀이 아닌 지속적인 연결을 사용하고 있습니다.</p>

<blockquote>
  <p><a href="https://stackoverflow.com/a/26450481">Generally speaking it’s because third party applications such as pgbouncer do it better.</a></p>
</blockquote>

<p>관련 링크:</p>

<ul>
  <li><a href="https://code.djangoproject.com/ticket/11798#no2">https://code.djangoproject.com/ticket/11798#no2</a></li>
</ul>

<h2 id="적절한-커넥션-개수는">적절한 커넥션 개수는?</h2>

<blockquote>
  <p>maxActive 값은 DBMS의 설정과 애플리케이션 서버의 개수, Apache, Tomcat에서 동시에 처리할 수 있는 사용자 수 등을 고려해서 설정해야 한다. DBMS가 수용할 수 있는 커넥션 개수를 확인한 후에 애플리케이션 서버 인스턴스 1개가 사용하기에 적절한 개수를 설정한다. 사용자가 몰려서 커넥션을 많이 사용할 때는 maxActive 값이 충분히 크지 않다면 병목 지점이 될 수 있다. 반대로 사용자가 적어서 사용 중인 커넥션이 많지 않은 시스템에서는 maxActive 값을 지나치게 작게 설정하지 않는 한 성능에 큰 영향이 없다.</p>
</blockquote>

<p><a href="https://d2.naver.com/helloworld/5102792">NAVER D2</a></p>

                </div>
            </section>

            <!-- Email subscribe form at the bottom of the page -->
            

            <footer class="post-full-footer">
                <!-- Everything inside the #author tags pulls data from the author -->
                <!-- #author-->
                
                    
                        <section class="author-card">
                            
                                <img class="author-profile-image" src="/assets/images/youngsup.jpg" alt="youngsup" />
                            
                            <section class="author-card-content">
                                <h4 class="author-card-name"><a href="/author/youngsup">Youngsup Oh</a></h4>
                                
                                    <p>I'm software developer.</p>
                                
                            </section>
                        </section>
                        <div class="post-full-footer-right">
                            <a class="author-card-button" href="/author/youngsup">Read More</a>
                        </div>
                    
                
                <!-- /author  -->
            </footer>

            <!-- If you use Disqus comments, just uncomment this block.
            The only thing you need to change is "test-apkdzgmqhj" - which
            should be replaced with your own Disqus site-id. -->
            
                <section class="post-full-comments">
                    <div id="disqus_thread"></div>
                    <script>
                        var disqus_config = function () {
                            this.page.url = 'https://ohing504.github.io/';
                            this.page.identifier = '502 Blog';
                        };
                        (function() {
                            var d = document, s = d.createElement('script');
                            s.src = 'https://ohing504.disqus.com/embed.js';
                            s.setAttribute('data-timestamp', +new Date());
                            (d.head || d.body).appendChild(s);
                        })();
                    </script>
                </section>
            

        </article>

    </div>
</main>

<!-- Links to Previous/Next posts -->
<aside class="read-next outer">
    <div class="inner">
        <div class="read-next-feed">
            
                
                
                
                
            

            <!-- If there's a next post, display it using the same markup included from - partials/post-card.hbs -->
            

            <!-- If there's a previous post, display it using the same markup included from - partials/post-card.hbs -->
            
                
    <article class="post-card post-template">
        
            <a class="post-card-image-link" href="/integrating-azure-notebooks-with-github">
                <div class="post-card-image" style="background-image: url(/assets/images/covers/jupyter-cover.png)"></div>
            </a>
        
        <div class="post-card-content">
            <a class="post-card-content-link" href="/integrating-azure-notebooks-with-github">
                <header class="post-card-header">
                    
                        
                            
                               <span class="post-card-tags">Github</span>
                            
                        
                            
                               <span class="post-card-tags">Azure notebooks</span>
                            
                        
                            
                               <span class="post-card-tags">Jupyter notebook</span>
                            
                        
                            
                               <span class="post-card-tags">Microsoft azure</span>
                            
                        
                            
                                <span class="post-card-tags">Jupyter</span>
                            
                        
                    

                    <h2 class="post-card-title">Integrating Azure Notebooks (Jupyter Notebooks) with GitHub</h2>
                </header>
                <section class="post-card-excerpt">
                    <p>Integrating Azure Notebooks (Jupyter Notebooks) with GitHub 오역 주의 원문: Integrating Azure Notebooks (Jupyter Notebooks) with GitHub 서론 Jupyter Notebook 은 다양한 유형의 분석 분야에서 사용할 수 있는 훌륭한 도구다. 최는 Jupyter Notebook</p>
                </section>
            </a>
            <footer class="post-card-meta">
                
                    
                        
                        <img class="author-profile-image" src="/assets/images/youngsup.jpg" alt="Youngsup Oh" />
                        
                        <span class="post-card-author">
                            <a href="/author/youngsup/">Youngsup Oh</a>
                        </span>
                    
                
            </footer>
        </div>
    </article>

            

        </div>
    </div>
</aside>

<!-- Floating header which appears on-scroll, included from includes/floating-header.hbs -->
<div class="floating-header">
    <div class="floating-header-logo">
        <a href="https://ohing504.github.io/">
            
                <img src="/assets/images/favicon.png" alt="502 Blog icon" />
            
            <span>502 Blog</span>
        </a>
    </div>
    <span class="floating-header-divider">&mdash;</span>
    <div class="floating-header-title">Database Connection Pool and Persistent Connection</div>
    <div class="floating-header-share">
        <div class="floating-header-share-label">Share this <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <path d="M7.5 15.5V4a1.5 1.5 0 1 1 3 0v4.5h2a1 1 0 0 1 1 1h2a1 1 0 0 1 1 1H18a1.5 1.5 0 0 1 1.5 1.5v3.099c0 .929-.13 1.854-.385 2.748L17.5 23.5h-9c-1.5-2-5.417-8.673-5.417-8.673a1.2 1.2 0 0 1 1.76-1.605L7.5 15.5zm6-6v2m-3-3.5v3.5m6-1v2"/>
</svg>
</div>
        <a class="floating-header-share-tw" href="https://twitter.com/share?text=Database+Connection+Pool+and+Persistent+Connection&amp;url=https://ohing504.github.io/database-connection"
            onclick="window.open(this.href, 'share-twitter', 'width=550,height=235');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M30.063 7.313c-.813 1.125-1.75 2.125-2.875 2.938v.75c0 1.563-.188 3.125-.688 4.625a15.088 15.088 0 0 1-2.063 4.438c-.875 1.438-2 2.688-3.25 3.813a15.015 15.015 0 0 1-4.625 2.563c-1.813.688-3.75 1-5.75 1-3.25 0-6.188-.875-8.875-2.625.438.063.875.125 1.375.125 2.688 0 5.063-.875 7.188-2.5-1.25 0-2.375-.375-3.375-1.125s-1.688-1.688-2.063-2.875c.438.063.813.125 1.125.125.5 0 1-.063 1.5-.25-1.313-.25-2.438-.938-3.313-1.938a5.673 5.673 0 0 1-1.313-3.688v-.063c.813.438 1.688.688 2.625.688a5.228 5.228 0 0 1-1.875-2c-.5-.875-.688-1.813-.688-2.75 0-1.063.25-2.063.75-2.938 1.438 1.75 3.188 3.188 5.25 4.25s4.313 1.688 6.688 1.813a5.579 5.579 0 0 1 1.5-5.438c1.125-1.125 2.5-1.688 4.125-1.688s3.063.625 4.188 1.813a11.48 11.48 0 0 0 3.688-1.375c-.438 1.375-1.313 2.438-2.563 3.188 1.125-.125 2.188-.438 3.313-.875z"/></svg>

        </a>
        <a class="floating-header-share-fb" href="https://www.facebook.com/sharer/sharer.php?u=https://ohing504.github.io/database-connection"
            onclick="window.open(this.href, 'share-facebook','width=580,height=296');return false;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32"><path d="M19 6h5V0h-5c-3.86 0-7 3.14-7 7v3H8v6h4v16h6V16h5l1-6h-6V7c0-.542.458-1 1-1z"/></svg>

        </a>
    </div>
    <progress class="progress" value="0">
        <div class="progress-container">
            <span class="progress-bar"></span>
        </div>
    </progress>
</div>


<!-- /post -->

<!-- The #contentFor helper here will send everything inside it up to the matching #block helper found in default.hbs -->


        <!-- Previous/next page links - displayed on every page -->
        

        <!-- The footer at the very bottom of the screen -->
        <footer class="site-footer outer">
            <div class="site-footer-content inner">
                <section class="copyright"><a href="https://ohing504.github.io/">502 Blog</a> &copy; 2018</section>
                <section class="poweredby">Proudly published with <a href="https://jekyllrb.com/">Jekyll</a> &
                    <a href="https://pages.github.com/" target="_blank" rel="noopener">GitHub Pages</a> using
                    <a href="https://github.com/jekyller/jasper2" target="_blank" rel="noopener">Jasper2</a></section>
                <nav class="site-footer-nav">
                    <a href="/">Latest Posts</a>
                    
                    
                    <a href="https://ghost.org" target="_blank" rel="noopener">Ghost</a>
                </nav>
            </div>
        </footer>

    </div>

    <!-- The big email subscribe modal content -->
    

    <!-- highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.10.0/components/prism-abap.min.js"></script>
    <script>$(document).ready(function() {
      $('pre code').each(function(i, block) {
        hljs.highlightBlock(block);
      });
    });</script>

    <!-- jQuery + Fitvids, which makes all video embeds responsive -->
    <script
        src="https://code.jquery.com/jquery-3.2.1.min.js"
        integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4="
        crossorigin="anonymous">
    </script>
    <script type="text/javascript" src="/assets/js/jquery.fitvids.js"></script>
    <script type="text/javascript" src="https://demo.ghost.io/assets/js/jquery.fitvids.js?v=724281a32e"></script>


    <!-- Paginator increased to "infinit" in _config.yml -->
    <!-- if paginator.posts  -->
    <!-- <script>
        var maxPages = parseInt('');
    </script>
    <script src="/assets/js/infinitescroll.js"></script> -->
    <!-- /endif -->

    


    <!-- Add Google Analytics  -->
    <!-- Google Analytics Tracking code -->
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-115908719-2', 'auto');
  ga('send', 'pageview');

 </script>


    <!-- The #block helper will pull in data from the #contentFor other template files. In this case, there's some JavaScript which we only want to use in post.hbs, but it needs to be included down here, after jQuery has already loaded. -->
    
        <script>

// NOTE: Scroll performance is poor in Safari
// - this appears to be due to the events firing much more slowly in Safari.
//   Dropping the scroll event and using only a raf loop results in smoother
//   scrolling but continuous processing even when not scrolling
$(document).ready(function () {
    // Start fitVids
    var $postContent = $(".post-full-content");
    $postContent.fitVids();
    // End fitVids

    var progressBar = document.querySelector('progress');
    var header = document.querySelector('.floating-header');
    var title = document.querySelector('.post-full-title');

    var lastScrollY = window.scrollY;
    var lastWindowHeight = window.innerHeight;
    var lastDocumentHeight = $(document).height();
    var ticking = false;

    function onScroll() {
        lastScrollY = window.scrollY;
        requestTick();
    }

    function onResize() {
        lastWindowHeight = window.innerHeight;
        lastDocumentHeight = $(document).height();
        requestTick();
    }

    function requestTick() {
        if (!ticking) {
            requestAnimationFrame(update);
        }
        ticking = true;
    }

    function update() {
        var trigger = title.getBoundingClientRect().top + window.scrollY;
        var triggerOffset = title.offsetHeight + 35;
        var progressMax = lastDocumentHeight - lastWindowHeight;

        // show/hide floating header
        if (lastScrollY >= trigger + triggerOffset) {
            header.classList.add('floating-active');
        } else {
            header.classList.remove('floating-active');
        }

        progressBar.setAttribute('max', progressMax);
        progressBar.setAttribute('value', lastScrollY);

        ticking = false;
    }

    window.addEventListener('scroll', onScroll, {passive: true});
    window.addEventListener('resize', onResize, false);

    update();
});
</script>

    

    <!-- Ghost outputs important scripts and data with this tag - it should always be the very last thing before the closing body tag -->
    <!-- ghost_foot -->

</body>
</html>
